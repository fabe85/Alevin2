/* ***** BEGIN LICENSE BLOCK *****
 * Copyright (C) 2010-2011, The VNREAL Project Team.
 * 
 * This work has been funded by the European FP7
 * Network of Excellence "Euro-NF" (grant agreement no. 216366)
 * through the Specific Joint Developments and Experiments Project
 * "Virtual Network Resource Embedding Algorithms" (VNREAL). 
 *
 * The VNREAL Project Team consists of members from:
 * - University of Wuerzburg, Germany
 * - Universitat Politecnica de Catalunya, Spain
 * - University of Passau, Germany
 * See the file AUTHORS for details and contact information.
 * 
 * This file is part of ALEVIN (ALgorithms for Embedding VIrtual Networks).
 *
 * ALEVIN is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License Version 3 or later
 * (the "GPL"), or the GNU Lesser General Public License Version 3 or later
 * (the "LGPL") as published by the Free Software Foundation.
 *
 * ALEVIN is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * or the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License and
 * GNU Lesser General Public License along with ALEVIN; see the file
 * COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * ***** END LICENSE BLOCK ***** */
package vnreal.algorithms.utils;

/**
 * Class to generate the data file needed by the LP solver 
 * to solve the LP problem. This data file will be processed 
 * with the models HHVNE-Model.mod and VNE-Model-NodeMapping.mod 
 * in /ILP-LP-Models solving a multicommodity flow problem with 
 * the substrate and virtual networks.
 * 
 *  See:
 *  M. Pioro and D. Medhi, Routing, Flow and Capacity Design in
 *  Communication and Computer Networks. San Francisco, CA: Morgan
 *  Kaufmann, 2004.
 * 
 * The data file and model file follow the GNU mathProg language. See:
 * 
 * http://www.gnu.org/software/glpk/#TOCdocumentation
 * 
 * @author Juan Felipe Botero
 * @since 2010-11-20
 */

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import vnreal.demands.AbstractDemand;
import vnreal.demands.BandwidthDemand;
import vnreal.demands.CpuDemand;
import vnreal.network.substrate.SubstrateLink;
import vnreal.network.substrate.SubstrateNetwork;
import vnreal.network.substrate.SubstrateNode;
import vnreal.network.virtual.VirtualLink;
import vnreal.network.virtual.VirtualNetwork;
import vnreal.network.virtual.VirtualNode;
import vnreal.resources.AbstractResource;
import vnreal.resources.BandwidthResource;
import vnreal.resources.CpuResource;

public class dataSolverFile {
	public dataSolverFile(String aFileName) {
		try {
			this.fstream = new FileWriter(aFileName);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/**
	 * Function to create the input file for the LP-solver (GLPK)
	 * 
	 * @param substrate
	 *            Substrate Network
	 * @param subsOriginal
	 *            Original substrate network before augmentation
	 * @param vNet
	 *            VNR to be mapped
	 * @param nodeMapping
	 *            Indication of the performed node mapping
	 * @param wBandwidth
	 *            Bandwidth considered weight
	 * @param wCPU
	 *            Cpu considered weight
	 * @param isNodeMapping
	 *            boolean to know if the data file will be for node or link
	 *            mapping
	 */

	public void createDataSolverFile(SubstrateNetwork substrate,
			SubstrateNetwork subsOriginal, VirtualNetwork vNet,
			Map<VirtualNode, SubstrateNode> nodeMapping, double wBandwidth,
			double wCPU, boolean isNodeMapping, double hhFactor) {
		boolean flag = true;
		SubstrateNode tempMapped, tempSrc, tempDst;
		VirtualNode tempVirNode;
		VirtualLink currVLink;
		Map<String, Double> linksToMap = new LinkedHashMap<String, Double>();
		Map<String, Double> linksToMapHhCpu = new LinkedHashMap<String, Double>();
		BandwidthDemand tempBwDem = null;
		CpuDemand tempHhCpuDem = null;

		try {
			// Create file
			BufferedWriter out = new BufferedWriter(this.fstream);
			out.write("/* Data file autogenerated */");
			out.write("\n\ndata;\n\n");
			out.write("set SNnodes :=");
			// Write substrate nodes in data file
			for (SubstrateNode n : substrate.getVertices())
				out.write(" " + Long.toString(n.getId()));

			if (isNodeMapping) {
				// For coordinate node and link mapping algorithm
				// The original substrate in node mapping
				out.write(";\n\n");
				out.write("set SNnodesOriginal :=");
				// Write substrate nodes in data file
				for (SubstrateNode n : subsOriginal.getVertices())
					out.write(" " + Long.toString(n.getId()));
			}

			out.write(";\n\n");
			out.write("set SNlinks :=");
			// Write substrate links in data file
			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				out.write(" ("
						+ Long.toString(substrate.getSource(temp).getId())
						+ ","
						+ Long.toString(substrate.getDest(temp).getId())
						+ ")");
			}

			if (isNodeMapping) {
				out.write(";\n\n");
				out.write("set SNlinksOriginal :=");
				// Write substrate links in data file
				for (Iterator<SubstrateLink> links = subsOriginal.getEdges()
						.iterator(); links.hasNext();) {
					SubstrateLink temp = links.next();
					out.write(" ("
							+ Long.toString(substrate.getSource(temp)
									.getId()) + ","
							+ Long.toString(substrate.getDest(temp).getId())
							+ ")");
				}
			}

			out.write(";\n\n");
			out.write("set VNnodes :=");
			List<SubstrateNode> mappedNodes = new LinkedList<SubstrateNode>();
			// Write virtual nodes in data file
			for (Iterator<VirtualNode> itt = vNet.getVertices().iterator(); itt
					.hasNext();) {
				tempVirNode = itt.next();
				tempMapped = nodeMapping.get(tempVirNode);

				if (!mappedNodes.contains(tempMapped))
					out.write(" " + Long.toString(tempMapped.getId()));

				mappedNodes.add(tempMapped);
			}

			out.write(";\n\n");
			out.write("set VNlinks :=");
			// Write virtual links in data file
			for (Iterator<VirtualLink> links = vNet.getEdges().iterator(); links
					.hasNext();) {
				currVLink = links.next();
				tempSrc = nodeMapping.get(vNet.getSource(currVLink));
				tempDst = nodeMapping.get(vNet.getDest(currVLink));
				if (!tempSrc.equals(tempDst)) {
					for (AbstractDemand dem : currVLink) {
						if (dem instanceof BandwidthDemand) {
							tempBwDem = (BandwidthDemand) dem;
							break;
						}
					}
					for (AbstractDemand dem : currVLink.getHiddenHopDemands()) {
						if (dem instanceof CpuDemand) {
							tempHhCpuDem = (CpuDemand) dem;
							break;
						}
					}
					if (!linksToMap
							.containsKey(Long.toString(tempSrc.getId())
									+ " " + Long.toString(tempDst.getId()))) {
						out.write(" (" + Long.toString(tempSrc.getId())
								+ "," + Long.toString(tempDst.getId()) + ")");
						linksToMap.put(Long.toString(tempSrc.getId()) + " "
								+ Long.toString(tempDst.getId()),
								tempBwDem.getDemandedBandwidth());
						if (tempHhCpuDem != null) {
							linksToMapHhCpu
									.put(Long.toString(tempSrc.getId())
											+ " "
											+ Long.toString(tempDst.getId()),
											tempHhCpuDem.getDemandedCycles());
						}
					} else {
						double tempBw = linksToMap.get(Long.toString(tempSrc
								.getId())
								+ " "
								+ Long.toString(tempDst.getId()))
								+ tempBwDem.getDemandedBandwidth();
						linksToMap.put(Long.toString(tempSrc.getId()) + " "
								+ Long.toString(tempDst.getId()), tempBw);
						if (tempHhCpuDem != null) {
							double temphHCpu = linksToMapHhCpu.get(Long
									.toString(tempSrc.getId())
									+ " "
									+ Long.toString(tempDst.getId()))
									+ tempHhCpuDem.getDemandedCycles();
							linksToMapHhCpu
									.put(Long.toString(tempSrc.getId())
											+ " "
											+ Long.toString(tempDst.getId()),
											temphHCpu);
						}
					}
				} else {
					// FIXME future work if node overload is considered and a
					// virtual link is mapped from one
					// substrate node to the same substrate node
				}
			}

			// Write substrate links bandwidth capacity
			out.write(";\n\n");
			out.write("param: \t\tLinkCapacity :=\n");
			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				for (AbstractResource res : temp) {
					// Change it, and instance of abstract resource
					if (res instanceof BandwidthResource) {
						if (flag) {
							flag = false;
						} else {
							out.write("\n");
						}
						out.write(Long.toString(substrate.getSource(temp)
								.getId())
								+ " "
								+ Long.toString(substrate.getDest(temp)
										.getId())
								+ " \t\t"
								+ Double.toString(((BandwidthResource) res)
										.getAvailableBandwidth()));
						break;
					}
				}
			}

			// If there are hidden hops present, write node capacities, (if
			// tempHhCpuDem!=null, hidden hops are considered)
			if (tempHhCpuDem != null || isNodeMapping) {
				out.write(";\n\n");
				out.write("param: \t\tSNodeCapacity :=\n");
				for (Iterator<SubstrateNode> nodes = substrate.getVertices()
						.iterator(); nodes.hasNext();) {
					SubstrateNode temp = nodes.next();
					for (AbstractResource res : temp) {
						// Change it, and instance of abstract resource
						if (res instanceof CpuResource) {
							if (flag) {
								flag = false;
							} else {
								out.write("\n");
							}
							out.write(Long.toString(temp.getId())
									+ " \t\t"
									+ Double.toString(((CpuResource) res)
											.getAvailableCycles()));
							break;
						}
					}
				}
			}

			// Write virtual links bandwidth demands
			out.write(";\n\n");
			out.write("param: \t\tVLinkDemand :=\n");
			for (Iterator<String> linkIterator = linksToMap.keySet().iterator(); linkIterator
					.hasNext();) {
				String currLink = linkIterator.next();
				if (flag) {
					flag = false;
				} else {
					out.write("\n");
				}
				out.write(currLink
						+ " \t\t"
						+ Double.toString(MiscelFunctions
								.roundThreeDecimals(linksToMap.get(currLink))));
			}

			if (isNodeMapping) {
				// Write virtual nodes cpu demand in data file
				out.write(";\n\n");
				out.write("param: \t\tVNodeDemand :=\n");
				mappedNodes = new LinkedList<SubstrateNode>();
				for (Iterator<VirtualNode> itt = vNet.getVertices().iterator(); itt
						.hasNext();) {
					tempVirNode = itt.next();
					tempMapped = nodeMapping.get(tempVirNode);

					if (!mappedNodes.contains(tempMapped)) {
						for (AbstractDemand dem : tempVirNode) {
							if (dem instanceof CpuDemand) {
								if (flag) {
									flag = false;
								} else {
									out.write("\n");
								}
								out.write(Long.toString(tempMapped.getId())
										+ " \t\t"
										+ Double.toString(((CpuDemand) dem)
												.getDemandedCycles()));
								break;
							}
						}

					}
					mappedNodes.add(tempMapped);
				}
			}

			// Write virtual links hidden hops CPU demands
			if (tempHhCpuDem != null && !isNodeMapping) {
				out.write(";\n\n");
				out.write("param: \t\tHHDemand :=\n");
				for (Iterator<String> linkIterator = linksToMapHhCpu.keySet()
						.iterator(); linkIterator.hasNext();) {
					String currLink = linkIterator.next();
					if (flag) {
						flag = false;
					} else {
						out.write("\n");
					}
					out.write(currLink
							+ " \t\t"
							+ Double.toString(MiscelFunctions
									.roundThreeDecimals(linksToMapHhCpu
											.get(currLink))));
				}
			}
			// Write weight of each parameter
			out.write(";\n\n");
			out.write("param w1 := " + Double.toString(wBandwidth) + ";\n");
			out.write("param w2 := " + Double.toString(wCPU) + ";\n");

			if (isNodeMapping) {
				out.write("param w3 := " + Double.toString(0.0001) + ";\n");
				out.write("param HHFactor := " + Double.toString(hhFactor)
						+ ";\n");
			}
			out.write("\n\nend;");
			// Close the output stream
			out.close();
		} catch (Exception e) {// Catch exception if any
			System.err.println("Error: " + e.getMessage());
		}

	}

	public void createExactMipSolverFile(SubstrateNetwork substrate,
			VirtualNetwork vNet,
			Map<VirtualNode, List<SubstrateNode>> candidateVirtual,
			double hhFactor, double wBandwidth, double wCPU,
			boolean sameNodeMapping) {

		try {
			// Create file
			BufferedWriter out = new BufferedWriter(this.fstream);
			out.write("/* Data file autogenerated */");
			out.write("\n\ndata;\n\n");
			out.write("set SNnodes :=");
			// Write substrate nodes in data file
			for (SubstrateNode n : substrate.getVertices())
				out.write(" " + Long.toString(n.getId()));

			out.write(";\n\n");
			out.write("set SNlinks :=");
			// Write substrate links in data file

			// This is placed if one substrate node can host two virtual nodes
			// and there are possibly a virtual link between thos two virtual
			// nodes
			if (sameNodeMapping) {
				for (Iterator<SubstrateNode> nodes = substrate.getVertices()
						.iterator(); nodes.hasNext();) {
					SubstrateNode sNode = nodes.next();
					out.write(" (" + Long.toString(sNode.getId()) + ","
							+ Long.toString(sNode.getId()) + ")");
				}
			}

			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				out.write(" ("
						+ Long.toString(substrate.getSource(temp).getId())
						+ ","
						+ Long.toString(substrate.getDest(temp).getId())
						+ ")");
			}

			out.write(";\n\n");
			out.write("set SNtotal :=");
			// Write SNtotal set in datafile (composed of SNVertices X
			// SNVertices)
			for (SubstrateNode i : substrate.getVertices())
				for (SubstrateNode j : substrate.getVertices()) {
					// Remove afterwards to allow same links and nodes
					if (!i.equals(j))
						out.write(" (" + Long.toString(i.getId()) + ","
								+ Long.toString(j.getId()) + ")");

				}

			out.write(";\n\n");
			out.write("set VNnodes :=");
			// Write virtual nodes in data file
			for (Iterator<VirtualNode> itt = vNet.getVertices().iterator(); itt
					.hasNext();)
				out.write(" " + Long.toString(itt.next().getId()));

			out.write(";\n\n");
			out.write("set VNlinks :=");
			// Write virtual links in data file
			for (Iterator<VirtualLink> links = vNet.getEdges().iterator(); links
					.hasNext();) {
				VirtualLink temp = links.next();
				out.write(" (" + Long.toString(vNet.getSource(temp).getId())
						+ "," + Long.toString(vNet.getDest(temp).getId())
						+ ")");
			}

			out.write(";\n\n");
			out.write("set candidateNodes :=");
			// Write candidate nodes for each virtual node
			for (Iterator<VirtualNode> node = candidateVirtual.keySet()
					.iterator(); node.hasNext();) {
				VirtualNode currVnode = node.next();
				for (SubstrateNode candiSnode : candidateVirtual.get(currVnode))
					out.write(" (" + Long.toString(currVnode.getId()) + ","
							+ Long.toString(candiSnode.getId()) + ")");
			}

			// Write substrate links bandwidth capacity
			out.write(";\n\n");
			out.write("param: \t\tLinkCapacity :=\n");
			if (sameNodeMapping) {
				// FIXME: Change the number 200 here!! (However it could be
				// any number.
				for (Iterator<SubstrateNode> nodes = substrate.getVertices()
						.iterator(); nodes.hasNext();) {
					SubstrateNode sNode = nodes.next();
					out.write(Long.toString(sNode.getId()) + " "
							+ Long.toString(sNode.getId()) + " \t\t"
							+ Double.toString(200) + "\n");
				}
			}

			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				for (AbstractResource res : temp) {
					if (res instanceof BandwidthResource) {
						out.write(Long.toString(substrate.getSource(temp)
								.getId())
								+ " "
								+ Long.toString(substrate.getDest(temp)
										.getId())
								+ " \t\t"
								+ Double.toString(((BandwidthResource) res)
										.getAvailableBandwidth()) + "\n");
						break;
					}
				}
			}

			// write node capacities
			out.write(";\n\n");
			out.write("param: \t\tSNodeCapacity :=\n");
			for (Iterator<SubstrateNode> nodes = substrate.getVertices()
					.iterator(); nodes.hasNext();) {
				SubstrateNode temp = nodes.next();
				for (AbstractResource res : temp) {
					// Change it, and instance of abstract resource
					if (res instanceof CpuResource) {
						out.write(Long.toString(temp.getId())
								+ " \t\t"
								+ Double.toString(((CpuResource) res)
										.getAvailableCycles()) + "\n");
						break;
					}
				}
			}

			// Write virtual links bandwidth demands
			out.write(";\n\n");
			out.write("param: \t\tVLinkDemand :=\n");
			for (Iterator<VirtualLink> links = vNet.getEdges().iterator(); links
					.hasNext();) {
				VirtualLink temp = links.next();
				for (AbstractDemand dem : temp) {
					if (dem instanceof BandwidthDemand) {
						out.write(Long
								.toString(vNet.getSource(temp).getId())
								+ " "
								+ Long.toString(vNet.getDest(temp).getId())
								+ " \t\t"
								+ Double.toString(((BandwidthDemand) dem)
										.getDemandedBandwidth()) + "\n");
						break;
					}
				}
			}

			// write node demands
			out.write(";\n\n");
			out.write("param: \t\tVNodeDemand :=\n");
			for (Iterator<VirtualNode> nodes = vNet.getVertices().iterator(); nodes
					.hasNext();) {
				VirtualNode temp = nodes.next();
				for (AbstractDemand dem : temp) {
					// Change it, and instance of abstract resource
					if (dem instanceof CpuDemand) {
						out.write(Long.toString(temp.getId())
								+ " \t\t"
								+ Double.toString(((CpuDemand) dem)
										.getDemandedCycles()) + "\n");
						break;
					}
				}
			}

			// Write weight of each parameter
			out.write(";\n\n");
			out.write("param w1 := " + Double.toString(wBandwidth) + ";\n");
			out.write("param w2 := " + Double.toString(wCPU) + ";\n");
			//if (sameNodeMapping) {
				out.write("param w3 :=0.0001;\n");
			//}
			out.write("param HHFactor := " + Double.toString(hhFactor) + ";\n");

			out.write("\n\nend;\n");
			// Close the output stream
			out.close();
		} catch (Exception e) {// Catch exception if any
			System.err.println("Error: " + e.getMessage());
		}
	}

	public void createSingleDataSolverFile(SubstrateNetwork substrate,
			SubstrateNode srcNode, SubstrateNode dstNode, VirtualLink vLink,
			double wCPU, double wBandwidth) {

		try {
			// Create file
			BufferedWriter out = new BufferedWriter(this.fstream);
			out.write("/* Data file autogenerated */");
			out.write("\n\ndata;\n\n");
			out.write("set SNnodes :=");
			// Write substrate nodes in data file
			for (SubstrateNode n : substrate.getVertices())
				out.write(" " + Long.toString(n.getId()));

			out.write(";\n\n");
			out.write("set SNlinks :=");
			// Write substrate links in data file
			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				out.write(" ("
						+ Long.toString(substrate.getSource(temp).getId())
						+ ","
						+ Long.toString(substrate.getDest(temp).getId())
						+ ")");
			}

			out.write(";\n\n");
			out.write("set VNnodes :=");
			out.write(" " + Long.toString(srcNode.getId()));
			out.write(" " + Long.toString(dstNode.getId()));

			out.write(";\n\n");
			out.write("set VNlinks :=");
			// Write virtual links in data file
			out.write(" (" + Long.toString(srcNode.getId()) + ","
					+ Long.toString(dstNode.getId()) + ")");

			// Write substrate links bandwidth capacity
			out.write(";\n\n");
			out.write("param: \t\tLinkCapacity :=\n");
			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				for (AbstractResource res : temp) {
					// Change it, and instance of abstract resource
					if (res instanceof BandwidthResource) {
						out.write(Long.toString(substrate.getSource(temp)
								.getId())
								+ " "
								+ Long.toString(substrate.getDest(temp)
										.getId())
								+ " \t\t"
								+ Double.toString(((BandwidthResource) res)
										.getAvailableBandwidth()) + "\n");
						break;
					}
				}
			}

			out.write(";\n\n");
			out.write("param: \t\tSNodeCapacity :=\n");
			for (Iterator<SubstrateNode> nodes = substrate.getVertices()
					.iterator(); nodes.hasNext();) {
				SubstrateNode temp = nodes.next();
				for (AbstractResource res : temp) {
					// Change it, and instance of abstract resource
					if (res instanceof CpuResource) {
						out.write(Long.toString(temp.getId())
								+ " \t\t"
								+ Double.toString(((CpuResource) res)
										.getAvailableCycles()) + "\n");
						break;
					}
				}
			}

			// Write virtual links bandwidth demands
			out.write(";\n\n");
			out.write("param: \t\tVLinkDemand :=\n");
			for (AbstractDemand dem : vLink) {
				// Change it, and instance of abstract resource
				if (dem instanceof BandwidthDemand) {
					out.write(Long.toString(srcNode.getId())
							+ " "
							+ Long.toString(dstNode.getId())
							+ " \t\t"
							+ Double.toString(((BandwidthDemand) dem)
									.getDemandedBandwidth()));
					break;
				}
			}

			// Write virtual links hidden hops CPU demands

			out.write(";\n\n");
			out.write("param: \t\tHHDemand :=\n");

			for (AbstractDemand dem : vLink.getHiddenHopDemands()) {
				// Change it, and instance of abstract resource
				if (dem instanceof CpuDemand) {
					out.write(Long.toString(srcNode.getId())
							+ " "
							+ Long.toString(dstNode.getId())
							+ " \t\t"
							+ Double.toString(((CpuDemand) dem)
									.getDemandedCycles()));
					break;
				}
			}

			// Write weight of each parameter
			out.write(";\n\n");
			out.write("param w1 := " + Double.toString(wBandwidth) + ";\n");
			out.write("param w2 := " + Double.toString(wCPU) + ";\n");

			out.write("\n\nend;\n");
			// Close the output stream
			out.close();
		} catch (Exception e) {// Catch exception if any
			System.err.println("Error: " + e.getMessage());
		}

	}

	public void createExactMipEnergySolverFile(SubstrateNetwork substrate,
			VirtualNetwork vNet,
			Map<VirtualNode, List<SubstrateNode>> candidateVirtual,
			double hhFactor, double roundingFactor, boolean sameNodeMapping) {
		try {
			// Create file
			BufferedWriter out = new BufferedWriter(this.fstream);
			out.write("/* Data file autogenerated */");
			out.write("\n\ndata;\n\n");
			out.write("set SNnodes :=");
			// Write substrate nodes in data file
			for (SubstrateNode n : substrate.getVertices())
				out.write(" " + Long.toString(n.getId()));

			out.write(";\n\n");
			out.write("set SNUnmappedNodes :=");
			// Write unmapped substrate nodes in data file
			for (SubstrateNode n : MiscelFunctions.getUnmappedNodes(substrate
					.getVertices()))
				out.write(" " + Long.toString(n.getId()));

			out.write(";\n\n");
			out.write("set SNlinks :=");
			// Write substrate links in data file

			// This is placed if one substrate node can host two virtual nodes
			// and there are possibly a virtual link between those two virtual
			// nodes
			if (sameNodeMapping) {
				for (Iterator<SubstrateNode> nodes = substrate.getVertices()
						.iterator(); nodes.hasNext();) {
					SubstrateNode sNode = nodes.next();
					out.write(" (" + Long.toString(sNode.getId()) + ","
							+ Long.toString(sNode.getId()) + ")");
				}
			}

			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				out.write(" ("
						+ Long.toString(substrate.getSource(temp).getId())
						+ ","
						+ Long.toString(substrate.getDest(temp).getId())
						+ ")");
			}

			out.write(";\n\n");
			out.write("set SNUnmappedLinks :=");
			// Write substrate links in data file
			for (SubstrateLink unmappedLink : MiscelFunctions
					.getUnmappedLinks(substrate.getEdges())) {
				out.write(" ("
						+ Long.toString(substrate.getSource(unmappedLink)
								.getId())
						+ ","
						+ Long.toString(substrate.getDest(unmappedLink)
								.getId()) + ")");
			}

			out.write(";\n\n");
			out.write("set SNtotal :=");
			// Write SNtotal set in datafile (composed of SNVertices X
			// SNVertices)
			for (SubstrateNode i : substrate.getVertices())
				for (SubstrateNode j : substrate.getVertices()) {
					if (!i.equals(j))
						out.write(" (" + Long.toString(i.getId()) + ","
								+ Long.toString(j.getId()) + ")");

				}

			out.write(";\n\n");
			out.write("set VNnodes :=");
			// Write virtual nodes in data file
			for (Iterator<VirtualNode> itt = vNet.getVertices().iterator(); itt
					.hasNext();)
				out.write(" " + Long.toString(itt.next().getId()));

			out.write(";\n\n");
			out.write("set VNlinks :=");
			// Write virtual links in data file
			for (Iterator<VirtualLink> links = vNet.getEdges().iterator(); links
					.hasNext();) {
				VirtualLink temp = links.next();
				out.write(" (" + Long.toString(vNet.getSource(temp).getId())
						+ "," + Long.toString(vNet.getDest(temp).getId())
						+ ")");
			}

			out.write(";\n\n");
			out.write("set candidateNodes :=");
			// Write candidate nodes for each virtual node
			for (Iterator<VirtualNode> node = candidateVirtual.keySet()
					.iterator(); node.hasNext();) {
				VirtualNode currVnode = node.next();
				for (SubstrateNode candiSnode : candidateVirtual.get(currVnode))
					out.write(" (" + Long.toString(currVnode.getId()) + ","
							+ Long.toString(candiSnode.getId()) + ")");
			}

			// Write substrate links bandwidth capacity
			out.write(";\n\n");
			out.write("param: \t\tLinkCapacity :=\n");
			if (sameNodeMapping) {
				// FIXME: Change the number 200 here!! (However it could be
				// any number.
				for (Iterator<SubstrateNode> nodes = substrate.getVertices()
						.iterator(); nodes.hasNext();) {
					SubstrateNode sNode = nodes.next();
					out.write(Long.toString(sNode.getId()) + " "
							+ Long.toString(sNode.getId()) + " \t\t"
							+ Double.toString(200) + "\n");
				}
			}
			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				for (AbstractResource res : temp) {
					if (res instanceof BandwidthResource) {
						out.write(Long.toString(substrate.getSource(temp)
								.getId())
								+ " "
								+ Long.toString(substrate.getDest(temp)
										.getId())
								+ " \t\t"
								+ Double.toString(((BandwidthResource) res)
										.getAvailableBandwidth()) + "\n");
						break;
					}
				}
			}

			// write node capacities
			out.write(";\n\n");
			out.write("param: \t\tSNodeCapacity :=\n");
			for (Iterator<SubstrateNode> nodes = substrate.getVertices()
					.iterator(); nodes.hasNext();) {
				SubstrateNode temp = nodes.next();
				for (AbstractResource res : temp) {
					// Change it, and instance of abstract resource
					if (res instanceof CpuResource) {
						out.write(Long.toString(temp.getId())
								+ " \t\t"
								+ Double.toString(((CpuResource) res)
										.getAvailableCycles()) + "\n");
						break;
					}
				}
			}

			// Write virtual links bandwidth demands
			out.write(";\n\n");
			out.write("param: \t\tVLinkDemand :=\n");
			for (Iterator<VirtualLink> links = vNet.getEdges().iterator(); links
					.hasNext();) {
				VirtualLink temp = links.next();
				for (AbstractDemand dem : temp) {
					if (dem instanceof BandwidthDemand) {
						out.write(Long
								.toString(vNet.getSource(temp).getId())
								+ " "
								+ Long.toString(vNet.getDest(temp).getId())
								+ " \t\t"
								+ Double.toString(((BandwidthDemand) dem)
										.getDemandedBandwidth()) + "\n");
						break;
					}
				}
			}

			// write node demands
			out.write(";\n\n");
			out.write("param: \t\tVNodeDemand :=\n");
			for (Iterator<VirtualNode> nodes = vNet.getVertices().iterator(); nodes
					.hasNext();) {
				VirtualNode temp = nodes.next();
				for (AbstractDemand dem : temp) {
					// Change it, and instance of abstract resource
					if (dem instanceof CpuDemand) {
						out.write(Long.toString(temp.getId())
								+ " \t\t"
								+ Double.toString(((CpuDemand) dem)
										.getDemandedCycles()) + "\n");
						break;
					}
				}
			}

			// Write weight of each parameter
			out.write(";\n\n");
			out.write("param HHFactor := " + Double.toString(hhFactor) + ";\n");
			out.write("param RoundingFactor := "
					+ Double.toString(roundingFactor) + ";\n");

			out.write("\n\nend;\n");
			// Close the output stream
			out.close();
		} catch (Exception e) {// Catch exception if any
			System.err.println("Error: " + e.getMessage());
		}
	}

	public void createSingleDataSolverFileEnergyAware(
			SubstrateNetwork substrate, SubstrateNode srcNode,
			SubstrateNode dstNode, VirtualLink vLink, double wCPU,
			double wBandwidth) {

		try {
			// Create file
			BufferedWriter out = new BufferedWriter(this.fstream);
			out.write("/* Data file autogenerated */");
			out.write("\n\ndata;\n\n");
			out.write("set SNnodes :=");
			// Write substrate nodes in data file
			for (SubstrateNode n : substrate.getVertices())
				out.write(" " + Long.toString(n.getId()));

			out.write(";\n\n");
			out.write("set SNlinks :=");
			// Write substrate links in data file
			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				out.write(" ("
						+ Long.toString(substrate.getSource(temp).getId())
						+ ","
						+ Long.toString(substrate.getDest(temp).getId())
						+ ")");
			}

			out.write(";\n\n");
			out.write("set SNUnmappedLinks :=");
			// Write substrate links in data file
			for (SubstrateLink unmappedLink : MiscelFunctions
					.getUnmappedLinks(substrate.getEdges())) {
				out.write(" ("
						+ Long.toString(substrate.getSource(unmappedLink)
								.getId())
						+ ","
						+ Long.toString(substrate.getDest(unmappedLink)
								.getId()) + ")");
			}

			out.write(";\n\n");
			out.write("set VNnodes :=");
			out.write(" " + Long.toString(srcNode.getId()));
			out.write(" " + Long.toString(dstNode.getId()));

			out.write(";\n\n");
			out.write("set VNlinks :=");
			// Write virtual links in data file
			out.write(" (" + Long.toString(srcNode.getId()) + ","
					+ Long.toString(dstNode.getId()) + ")");

			// Write substrate links bandwidth capacity
			out.write(";\n\n");
			out.write("param: \t\tLinkCapacity :=\n");
			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				for (AbstractResource res : temp) {
					// Change it, and instance of abstract resource
					if (res instanceof BandwidthResource) {
						out.write(Long.toString(substrate.getSource(temp)
								.getId())
								+ " "
								+ Long.toString(substrate.getDest(temp)
										.getId())
								+ " \t\t"
								+ Double.toString(((BandwidthResource) res)
										.getAvailableBandwidth()) + "\n");
						break;
					}
				}
			}

			out.write(";\n\n");
			out.write("param: \t\tSNodeCapacity :=\n");
			for (Iterator<SubstrateNode> nodes = substrate.getVertices()
					.iterator(); nodes.hasNext();) {
				SubstrateNode temp = nodes.next();
				for (AbstractResource res : temp) {
					// Change it, and instance of abstract resource
					if (res instanceof CpuResource) {
						out.write(Long.toString(temp.getId())
								+ " \t\t"
								+ Double.toString(((CpuResource) res)
										.getAvailableCycles()) + "\n");
						break;
					}
				}
			}

			// Write virtual links bandwidth demands
			out.write(";\n\n");
			out.write("param: \t\tVLinkDemand :=\n");
			for (AbstractDemand dem : vLink) {
				// Change it, and instance of abstract resource
				if (dem instanceof BandwidthDemand) {
					out.write(Long.toString(srcNode.getId())
							+ " "
							+ Long.toString(dstNode.getId())
							+ " \t\t"
							+ Double.toString(((BandwidthDemand) dem)
									.getDemandedBandwidth()));
					break;
				}
			}

			// Write virtual links hidden hops CPU demands

			out.write(";\n\n");
			out.write("param: \t\tHHDemand :=\n");

			for (AbstractDemand dem : vLink.getHiddenHopDemands()) {
				// Change it, and instance of abstract resource
				if (dem instanceof CpuDemand) {
					out.write(Long.toString(srcNode.getId())
							+ " "
							+ Long.toString(dstNode.getId())
							+ " \t\t"
							+ Double.toString(((CpuDemand) dem)
									.getDemandedCycles()));
					break;
				}
			}

			// Write weight of each parameter
			out.write(";\n\n");
			out.write("param w1 := " + Double.toString(wBandwidth) + ";\n");
			out.write("param w2 := " + Double.toString(wCPU) + ";\n");

			out.write("\n\nend;\n");
			// Close the output stream
			out.close();
		} catch (Exception e) {// Catch exception if any
			System.err.println("Error: " + e.getMessage());
		}

	}

	public void tempSolverRemappingFileEA(SubstrateNetwork substrate,
			List<SubstrateNode> srcNodeList, List<SubstrateNode> dstNodeList,
			List<VirtualLink> vLinkList, List<SubstrateLink> noTouchSLinkList) {
		List<SubstrateNode> occNodes = new LinkedList<SubstrateNode>();
		Map<String, Double> linksToMap = new LinkedHashMap<String, Double>();
		Map<String, Double> linksToMapHhCpu = new LinkedHashMap<String, Double>();
		CpuDemand tempHhCpuDem = null;
		BandwidthDemand tempBwDem = null;
		try {
			// Create file
			BufferedWriter out = new BufferedWriter(this.fstream);
			out.write("/* Data file autogenerated */");
			out.write("\n\ndata;\n\n");
			out.write("set SNnodes :=");
			// Write substrate nodes in data file
			for (SubstrateNode n : substrate.getVertices())
				out.write(" " + Long.toString(n.getId()));

			out.write(";\n\n");
			out.write("set SNlinks :=");
			// Write substrate links in data file
			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				out.write(" ("
						+ Long.toString(substrate.getSource(temp).getId())
						+ ","
						+ Long.toString(substrate.getDest(temp).getId())
						+ ")");
			}

			out.write(";\n\n");
			out.write("set NoTouchLinks := ");
			// Write substrate links in data file
			for (SubstrateLink unmappedLink : noTouchSLinkList) {
				out.write(" ("
						+ Long.toString(substrate.getSource(unmappedLink)
								.getId())
						+ ","
						+ Long.toString(substrate.getDest(unmappedLink)
								.getId()) + ")");
			}

			out.write(";\n\n");
			out.write("set SNUnmappedLinks :=");
			// Write substrate links in data file
			for (SubstrateLink unmappedLink : MiscelFunctions
					.getUnmappedLinks(substrate.getEdges())) {
				out.write(" ("
						+ Long.toString(substrate.getSource(unmappedLink)
								.getId())
						+ ","
						+ Long.toString(substrate.getDest(unmappedLink)
								.getId()) + ")");
			}

			out.write(";\n\n");
			out.write("set VNnodes :=");
			// Write virtual nodes in data file
			for (SubstrateNode tmpSnode : srcNodeList) {

				if (!occNodes.contains(tmpSnode))
					out.write(" " + Long.toString(tmpSnode.getId()));

				occNodes.add(tmpSnode);
			}

			for (SubstrateNode tmpSnode : dstNodeList) {

				if (!occNodes.contains(tmpSnode))
					out.write(" " + Long.toString(tmpSnode.getId()));

				occNodes.add(tmpSnode);
			}
			out.write(";\n\n");
			out.write("set VNlinks :=");
			// Write virtual links in data file
			for (int i = 0; i < srcNodeList.size(); i++) {
				for (AbstractDemand dem : vLinkList.get(i)) {
					if (dem instanceof BandwidthDemand) {
						tempBwDem = (BandwidthDemand) dem;
						break;
					}
				}
				tempHhCpuDem = null;
				for (AbstractDemand dem : vLinkList.get(i)
						.getHiddenHopDemands()) {
					if (dem instanceof CpuDemand) {
						tempHhCpuDem = (CpuDemand) dem;
						break;
					}
				}

				if (!linksToMap.containsKey(Long.toString(srcNodeList.get(i)
						.getId())
						+ " "
						+ Long.toString(dstNodeList.get(i).getId()))) {

					out.write(" ("
							+ Long.toString(srcNodeList.get(i).getId())
							+ ","
							+ Long.toString(dstNodeList.get(i).getId())
							+ ")");

					linksToMap.put(
							Long.toString(srcNodeList.get(i).getId())
									+ " "
									+ Long.toString(dstNodeList.get(i)
											.getId()),
							tempBwDem.getDemandedBandwidth());

					if (tempHhCpuDem != null) {
						linksToMapHhCpu.put(
								Long.toString(srcNodeList.get(i).getId())
										+ " "
										+ Long.toString(dstNodeList.get(i)
												.getId()),
								tempHhCpuDem.getDemandedCycles());
					}

				} else {
					double tempBw = linksToMap.get(Long.toString(srcNodeList
							.get(i).getId())
							+ " "
							+ Long.toString(dstNodeList.get(i).getId()))
							+ tempBwDem.getDemandedBandwidth();
					linksToMap.put(
							Long.toString(srcNodeList.get(i).getId())
									+ " "
									+ Long.toString(dstNodeList.get(i)
											.getId()), tempBw);
					if (tempHhCpuDem != null) {
						double temphHCpu = linksToMapHhCpu.get(Long
								.toString(srcNodeList.get(i).getId())
								+ " "
								+ Long.toString(dstNodeList.get(i).getId()))
								+ tempHhCpuDem.getDemandedCycles();
						linksToMapHhCpu.put(
								Long.toString(srcNodeList.get(i).getId())
										+ " "
										+ Long.toString(dstNodeList.get(i)
												.getId()), temphHCpu);
					}
				}
			}

			// Write substrate links bandwidth capacity
			out.write(";\n\n");
			out.write("param: \t\tLinkCapacity :=\n");
			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				for (AbstractResource res : temp) {
					// Change it, and instance of abstract resource
					if (res instanceof BandwidthResource) {
						out.write(Long.toString(substrate.getSource(temp)
								.getId())
								+ " "
								+ Long.toString(substrate.getDest(temp)
										.getId())
								+ " \t\t"
								+ Double.toString(((BandwidthResource) res)
										.getAvailableBandwidth()) + "\n");
						break;
					}
				}
			}

			// Write virtual links bandwidth demands
			out.write(";\n\n");
			out.write("param: \t\tVLinkDemand :=\n");
			for (Iterator<String> linkIterator = linksToMap.keySet().iterator(); linkIterator
					.hasNext();) {
				String currLink = linkIterator.next();
				out.write(currLink
						+ " \t\t"
						+ Double.toString(MiscelFunctions
								.roundThreeDecimals(linksToMap.get(currLink)))
						+ "\n");
			}

			out.write(";\n\nend;\n");
			// Close the output stream
			out.close();
		} catch (Exception e) {// Catch exception if any
			System.err.println("Error: " + e.getMessage());
		}

	}

	public void createDataSolverFileEnergyAware(SubstrateNetwork substrate,
			VirtualNetwork vNet, Map<VirtualNode, SubstrateNode> nodeMapping,
			double wBandwidth, double wCPU) {
		boolean flag = true;
		SubstrateNode tempMapped, tempSrc, tempDst;
		VirtualNode tempVirNode;
		VirtualLink currVLink;
		Map<String, Double> linksToMap = new LinkedHashMap<String, Double>();
		Map<String, Double> linksToMapHhCpu = new LinkedHashMap<String, Double>();
		BandwidthDemand tempBwDem = null;
		CpuDemand tempHhCpuDem = null;

		try {
			// Create file
			BufferedWriter out = new BufferedWriter(this.fstream);
			out.write("/* Data file autogenerated */");
			out.write("\n\ndata;\n\n");
			out.write("set SNnodes :=");
			// Write substrate nodes in data file
			for (SubstrateNode n : substrate.getVertices())
				out.write(" " + Long.toString(n.getId()));

			out.write(";\n\n");
			out.write("set SNlinks :=");
			// Write substrate links in data file
			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				out.write(" ("
						+ Long.toString(substrate.getSource(temp).getId())
						+ ","
						+ Long.toString(substrate.getDest(temp).getId())
						+ ")");
			}

			out.write(";\n\n");
			out.write("set SNUnmappedLinks :=");
			// Write substrate links in data file
			for (SubstrateLink unmappedLink : MiscelFunctions
					.getUnmappedLinks(substrate.getEdges())) {
				out.write(" ("
						+ Long.toString(substrate.getSource(unmappedLink)
								.getId())
						+ ","
						+ Long.toString(substrate.getDest(unmappedLink)
								.getId()) + ")");
			}

			out.write(";\n\n");
			out.write("set VNnodes :=");
			List<SubstrateNode> mappedNodes = new LinkedList<SubstrateNode>();
			// Write virtual nodes in data file
			for (Iterator<VirtualNode> itt = vNet.getVertices().iterator(); itt
					.hasNext();) {
				tempVirNode = itt.next();
				tempMapped = nodeMapping.get(tempVirNode);

				if (!mappedNodes.contains(tempMapped))
					out.write(" " + Long.toString(tempMapped.getId()));

				mappedNodes.add(tempMapped);
			}

			out.write(";\n\n");
			out.write("set VNlinks :=");
			// Write virtual links in data file
			for (Iterator<VirtualLink> links = vNet.getEdges().iterator(); links
					.hasNext();) {
				currVLink = links.next();
				tempSrc = nodeMapping.get(vNet.getSource(currVLink));
				tempDst = nodeMapping.get(vNet.getDest(currVLink));
				if (!tempSrc.equals(tempDst)) {
					for (AbstractDemand dem : currVLink) {
						if (dem instanceof BandwidthDemand) {
							tempBwDem = (BandwidthDemand) dem;
							break;
						}
					}
					for (AbstractDemand dem : currVLink.getHiddenHopDemands()) {
						if (dem instanceof CpuDemand) {
							tempHhCpuDem = (CpuDemand) dem;
							break;
						}
					}
					if (!linksToMap
							.containsKey(Long.toString(tempSrc.getId())
									+ " " + Long.toString(tempDst.getId()))) {
						out.write(" (" + Long.toString(tempSrc.getId())
								+ "," + Long.toString(tempDst.getId()) + ")");
						linksToMap.put(Long.toString(tempSrc.getId()) + " "
								+ Long.toString(tempDst.getId()),
								tempBwDem.getDemandedBandwidth());
						if (tempHhCpuDem != null) {
							linksToMapHhCpu
									.put(Long.toString(tempSrc.getId())
											+ " "
											+ Long.toString(tempDst.getId()),
											tempHhCpuDem.getDemandedCycles());
						}
					} else {
						double tempBw = linksToMap.get(Long.toString(tempSrc
								.getId())
								+ " "
								+ Long.toString(tempDst.getId()))
								+ tempBwDem.getDemandedBandwidth();
						linksToMap.put(Long.toString(tempSrc.getId()) + " "
								+ Long.toString(tempDst.getId()), tempBw);
						if (tempHhCpuDem != null) {
							double temphHCpu = linksToMapHhCpu.get(Long
									.toString(tempSrc.getId())
									+ " "
									+ Long.toString(tempDst.getId()))
									+ tempHhCpuDem.getDemandedCycles();
							linksToMapHhCpu
									.put(Long.toString(tempSrc.getId())
											+ " "
											+ Long.toString(tempDst.getId()),
											temphHCpu);
						}
					}
				} else {
					// FIXME future work if node overload is considered and a
					// virtual link is mapped from one
					// substrate node to the same substrate node
				}
			}

			// Write substrate links bandwidth capacity
			out.write(";\n\n");
			out.write("param: \t\tLinkCapacity :=\n");
			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				for (AbstractResource res : temp) {
					// Change it, and instance of abstract resource
					if (res instanceof BandwidthResource) {
						if (flag) {
							flag = false;
						} else {
							out.write("\n");
						}
						out.write(Long.toString(substrate.getSource(temp)
								.getId())
								+ " "
								+ Long.toString(substrate.getDest(temp)
										.getId())
								+ " \t\t"
								+ Double.toString(((BandwidthResource) res)
										.getAvailableBandwidth()));
						break;
					}
				}
			}

			// If there are hidden hops present, write node capacities, (if
			// tempHhCpuDem!=null, hidden hops are considered)
			if (tempHhCpuDem != null) {
				out.write(";\n\n");
				out.write("param: \t\tSNodeCapacity :=\n");
				for (Iterator<SubstrateNode> nodes = substrate.getVertices()
						.iterator(); nodes.hasNext();) {
					SubstrateNode temp = nodes.next();
					for (AbstractResource res : temp) {
						// Change it, and instance of abstract resource
						if (res instanceof CpuResource) {
							if (flag) {
								flag = false;
							} else {
								out.write("\n");
							}
							out.write(Long.toString(temp.getId())
									+ " \t\t"
									+ Double.toString(((CpuResource) res)
											.getAvailableCycles()));
							break;
						}
					}
				}
			}

			// Write virtual links bandwidth demands
			out.write(";\n\n");
			out.write("param: \t\tVLinkDemand :=\n");
			for (Iterator<String> linkIterator = linksToMap.keySet().iterator(); linkIterator
					.hasNext();) {
				String currLink = linkIterator.next();
				if (flag) {
					flag = false;
				} else {
					out.write("\n");
				}
				out.write(currLink
						+ " \t\t"
						+ Double.toString(MiscelFunctions
								.roundThreeDecimals(linksToMap.get(currLink))));
			}

			// Write virtual links hidden hops CPU demands
			if (tempHhCpuDem != null) {
				out.write(";\n\n");
				out.write("param: \t\tHHDemand :=\n");
				for (Iterator<String> linkIterator = linksToMapHhCpu.keySet()
						.iterator(); linkIterator.hasNext();) {
					String currLink = linkIterator.next();
					if (flag) {
						flag = false;
					} else {
						out.write("\n");
					}
					out.write(currLink
							+ " \t\t"
							+ Double.toString(MiscelFunctions
									.roundThreeDecimals(linksToMapHhCpu
											.get(currLink))));
				}
			}
			// Write weight of each parameter
			out.write(";\n\n");
			out.write("param w1 := " + Double.toString(wBandwidth) + ";\n");
			out.write("param w2 := " + Double.toString(wCPU) + ";\n");
			out.write("\n\nend;\n");
			// Close the output stream
			out.close();
		} catch (Exception e) {// Catch exception if any
			System.err.println("Error: " + e.getMessage());
		}

	}

	public void createDataSolverFileNodeMappingEnergyTest(
			SubstrateNetwork substrate, SubstrateNetwork subsOriginal,
			VirtualNetwork vNet, Map<VirtualNode, SubstrateNode> nodeMapping,
			boolean isNodeMapping, double hhFactor) {
		boolean flag = true;
		SubstrateNode tempMapped, tempSrc, tempDst;
		VirtualNode tempVirNode;
		VirtualLink currVLink;
		Map<String, Double> linksToMap = new LinkedHashMap<String, Double>();
		Map<String, Double> linksToMapHhCpu = new LinkedHashMap<String, Double>();
		BandwidthDemand tempBwDem = null;
		CpuDemand tempHhCpuDem = null;

		try {
			// Create file
			BufferedWriter out = new BufferedWriter(this.fstream);
			out.write("/* Data file autogenerated */");
			out.write("\n\ndata;\n\n");
			out.write("set SNnodes :=");
			// Write substrate nodes in data file
			for (SubstrateNode n : substrate.getVertices())
				out.write(" " + Long.toString(n.getId()));

			if (isNodeMapping) {
				// For coordinate node and link mapping algorithm
				// The original substrate in node mapping
				out.write(";\n\n");
				out.write("set SNnodesOriginal :=");
				// Write substrate nodes in data file
				for (SubstrateNode n : subsOriginal.getVertices())
					out.write(" " + Long.toString(n.getId()));
			}

			out.write(";\n\n");
			out.write("set SNUnmappedNodes :=");
			// Write unmapped substrate nodes in data file
			for (SubstrateNode n : MiscelFunctions.getUnmappedNodes(substrate
					.getVertices()))
				out.write(" " + Long.toString(n.getId()));

			out.write(";\n\n");
			out.write("set SNlinks :=");
			// Write substrate links in data file
			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				out.write(" ("
						+ Long.toString(substrate.getSource(temp).getId())
						+ ","
						+ Long.toString(substrate.getDest(temp).getId())
						+ ")");
			}

			if (isNodeMapping) {
				out.write(";\n\n");
				out.write("set SNlinksOriginal :=");
				// Write substrate links in data file
				for (Iterator<SubstrateLink> links = subsOriginal.getEdges()
						.iterator(); links.hasNext();) {
					SubstrateLink temp = links.next();
					out.write(" ("
							+ Long.toString(substrate.getSource(temp)
									.getId()) + ","
							+ Long.toString(substrate.getDest(temp).getId())
							+ ")");
				}
			}

			out.write(";\n\n");
			out.write("set VNnodes :=");
			List<SubstrateNode> mappedNodes = new LinkedList<SubstrateNode>();
			// Write virtual nodes in data file
			for (Iterator<VirtualNode> itt = vNet.getVertices().iterator(); itt
					.hasNext();) {
				tempVirNode = itt.next();
				tempMapped = nodeMapping.get(tempVirNode);

				if (!mappedNodes.contains(tempMapped))
					out.write(" " + Long.toString(tempMapped.getId()));

				mappedNodes.add(tempMapped);
			}

			out.write(";\n\n");
			out.write("set VNlinks :=");
			// Write virtual links in data file
			for (Iterator<VirtualLink> links = vNet.getEdges().iterator(); links
					.hasNext();) {
				currVLink = links.next();
				tempSrc = nodeMapping.get(vNet.getSource(currVLink));
				tempDst = nodeMapping.get(vNet.getDest(currVLink));
				if (!tempSrc.equals(tempDst)) {
					for (AbstractDemand dem : currVLink) {
						if (dem instanceof BandwidthDemand) {
							tempBwDem = (BandwidthDemand) dem;
							break;
						}
					}
					for (AbstractDemand dem : currVLink.getHiddenHopDemands()) {
						if (dem instanceof CpuDemand) {
							tempHhCpuDem = (CpuDemand) dem;
							break;
						}
					}
					if (!linksToMap
							.containsKey(Long.toString(tempSrc.getId())
									+ " " + Long.toString(tempDst.getId()))) {
						out.write(" (" + Long.toString(tempSrc.getId())
								+ "," + Long.toString(tempDst.getId()) + ")");
						linksToMap.put(Long.toString(tempSrc.getId()) + " "
								+ Long.toString(tempDst.getId()),
								tempBwDem.getDemandedBandwidth());
						if (tempHhCpuDem != null) {
							linksToMapHhCpu
									.put(Long.toString(tempSrc.getId())
											+ " "
											+ Long.toString(tempDst.getId()),
											tempHhCpuDem.getDemandedCycles());
						}
					} else {
						double tempBw = linksToMap.get(Long.toString(tempSrc
								.getId())
								+ " "
								+ Long.toString(tempDst.getId()))
								+ tempBwDem.getDemandedBandwidth();
						linksToMap.put(Long.toString(tempSrc.getId()) + " "
								+ Long.toString(tempDst.getId()), tempBw);
						if (tempHhCpuDem != null) {
							double temphHCpu = linksToMapHhCpu.get(Long
									.toString(tempSrc.getId())
									+ " "
									+ Long.toString(tempDst.getId()))
									+ tempHhCpuDem.getDemandedCycles();
							linksToMapHhCpu
									.put(Long.toString(tempSrc.getId())
											+ " "
											+ Long.toString(tempDst.getId()),
											temphHCpu);
						}
					}
				} else {
					// FIXME future work if node overload is considered and a
					// virtual link is mapped from one
					// substrate node to the same substrate node
				}
			}

			// Write substrate links bandwidth capacity
			out.write(";\n\n");
			out.write("param: \t\tLinkCapacity :=\n");
			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				for (AbstractResource res : temp) {
					// Change it, and instance of abstract resource
					if (res instanceof BandwidthResource) {
						if (flag) {
							flag = false;
						} else {
							out.write("\n");
						}
						out.write(Long.toString(substrate.getSource(temp)
								.getId())
								+ " "
								+ Long.toString(substrate.getDest(temp)
										.getId())
								+ " \t\t"
								+ Double.toString(((BandwidthResource) res)
										.getAvailableBandwidth()));
						break;
					}
				}
			}

			// If there are hidden hops present, write node capacities, (if
			// tempHhCpuDem!=null, hidden hops are considered)
			if (tempHhCpuDem != null || isNodeMapping) {
				out.write(";\n\n");
				out.write("param: \t\tSNodeCapacity :=\n");
				for (Iterator<SubstrateNode> nodes = substrate.getVertices()
						.iterator(); nodes.hasNext();) {
					SubstrateNode temp = nodes.next();
					for (AbstractResource res : temp) {
						// Change it, and instance of abstract resource
						if (res instanceof CpuResource) {
							if (flag) {
								flag = false;
							} else {
								out.write("\n");
							}
							out.write(Long.toString(temp.getId())
									+ " \t\t"
									+ Double.toString(((CpuResource) res)
											.getAvailableCycles()));
							break;
						}
					}
				}
			}

			// Write virtual links bandwidth demands
			out.write(";\n\n");
			out.write("param: \t\tVLinkDemand :=\n");
			for (Iterator<String> linkIterator = linksToMap.keySet().iterator(); linkIterator
					.hasNext();) {
				String currLink = linkIterator.next();
				if (flag) {
					flag = false;
				} else {
					out.write("\n");
				}
				out.write(currLink
						+ " \t\t"
						+ Double.toString(MiscelFunctions
								.roundThreeDecimals(linksToMap.get(currLink))));
			}

			if (isNodeMapping) {
				// Write virtual nodes cpu demand in data file
				out.write(";\n\n");
				out.write("param: \t\tVNodeDemand :=\n");
				mappedNodes = new LinkedList<SubstrateNode>();
				for (Iterator<VirtualNode> itt = vNet.getVertices().iterator(); itt
						.hasNext();) {
					tempVirNode = itt.next();
					tempMapped = nodeMapping.get(tempVirNode);

					if (!mappedNodes.contains(tempMapped)) {
						for (AbstractDemand dem : tempVirNode) {
							if (dem instanceof CpuDemand) {
								if (flag) {
									flag = false;
								} else {
									out.write("\n");
								}
								out.write(Long.toString(tempMapped.getId())
										+ " \t\t"
										+ Double.toString(((CpuDemand) dem)
												.getDemandedCycles()));
								break;
							}
						}

					}
					mappedNodes.add(tempMapped);
				}
			}

			// Write virtual links hidden hops CPU demands
			if (tempHhCpuDem != null && !isNodeMapping) {
				out.write(";\n\n");
				out.write("param: \t\tHHDemand :=\n");
				for (Iterator<String> linkIterator = linksToMapHhCpu.keySet()
						.iterator(); linkIterator.hasNext();) {
					String currLink = linkIterator.next();
					if (flag) {
						flag = false;
					} else {
						out.write("\n");
					}
					out.write(currLink
							+ " \t\t"
							+ Double.toString(MiscelFunctions
									.roundThreeDecimals(linksToMapHhCpu
											.get(currLink))));
				}
			}
			// Write weight of each parameter
			out.write(";\n\n");
			if (isNodeMapping) {
				out.write("param HHFactor := " + Double.toString(hhFactor)
						+ ";\n");
			}
			out.write("\n\nend;\n");
			// Close the output stream
			out.close();
		} catch (Exception e) {// Catch exception if any
			System.err.println("Error: " + e.getMessage());
		}

	}

	public void createExactMipEnergySolverFileWithCost(
			SubstrateNetwork substrate, VirtualNetwork vNet,
			Map<VirtualNode, List<SubstrateNode>> candidateVirtual,
			double hhFactor, double roundingFactor, boolean sameNodeMapping,
			double w1, double w2) {
		try {
			// Create file
			BufferedWriter out = new BufferedWriter(this.fstream);
			out.write("/* Data file autogenerated */");
			out.write("\n\ndata;\n\n");
			out.write("set SNnodes :=");
			// Write substrate nodes in data file
			for (SubstrateNode n : substrate.getVertices())
				out.write(" " + Long.toString(n.getId()));

			out.write(";\n\n");
			out.write("set SNUnmappedNodes :=");
			// Write unmapped substrate nodes in data file
			for (SubstrateNode n : MiscelFunctions.getUnmappedNodes(substrate
					.getVertices()))
				out.write(" " + Long.toString(n.getId()));

			out.write(";\n\n");
			out.write("set SNlinks :=");
			// Write substrate links in data file

			// This is placed if one substrate node can host two virtual nodes
			// and there are possibly a virtual link between those two virtual
			// nodes
			if (sameNodeMapping) {
				for (Iterator<SubstrateNode> nodes = substrate.getVertices()
						.iterator(); nodes.hasNext();) {
					SubstrateNode sNode = nodes.next();
					out.write(" (" + Long.toString(sNode.getId()) + ","
							+ Long.toString(sNode.getId()) + ")");
				}
			}

			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				out.write(" ("
						+ Long.toString(substrate.getSource(temp).getId())
						+ ","
						+ Long.toString(substrate.getDest(temp).getId())
						+ ")");
			}

			out.write(";\n\n");
			out.write("set SNUnmappedLinks :=");
			// Write substrate links in data file
			for (SubstrateLink unmappedLink : MiscelFunctions
					.getUnmappedLinks(substrate.getEdges())) {
				out.write(" ("
						+ Long.toString(substrate.getSource(unmappedLink)
								.getId())
						+ ","
						+ Long.toString(substrate.getDest(unmappedLink)
								.getId()) + ")");
			}

			out.write(";\n\n");
			out.write("set SNtotal :=");
			// Write SNtotal set in datafile (composed of SNVertices X
			// SNVertices)
			for (SubstrateNode i : substrate.getVertices())
				for (SubstrateNode j : substrate.getVertices()) {
					if (!i.equals(j))
						out.write(" (" + Long.toString(i.getId()) + ","
								+ Long.toString(j.getId()) + ")");

				}

			out.write(";\n\n");
			out.write("set VNnodes :=");
			// Write virtual nodes in data file
			for (Iterator<VirtualNode> itt = vNet.getVertices().iterator(); itt
					.hasNext();)
				out.write(" " + Long.toString(itt.next().getId()));

			out.write(";\n\n");
			out.write("set VNlinks :=");
			// Write virtual links in data file
			for (Iterator<VirtualLink> links = vNet.getEdges().iterator(); links
					.hasNext();) {
				VirtualLink temp = links.next();
				out.write(" (" + Long.toString(vNet.getSource(temp).getId())
						+ "," + Long.toString(vNet.getDest(temp).getId())
						+ ")");
			}

			out.write(";\n\n");
			out.write("set candidateNodes :=");
			// Write candidate nodes for each virtual node
			for (Iterator<VirtualNode> node = candidateVirtual.keySet()
					.iterator(); node.hasNext();) {
				VirtualNode currVnode = node.next();
				for (SubstrateNode candiSnode : candidateVirtual.get(currVnode))
					out.write(" (" + Long.toString(currVnode.getId()) + ","
							+ Long.toString(candiSnode.getId()) + ")");
			}

			// Write substrate links bandwidth capacity
			out.write(";\n\n");
			out.write("param: \t\tLinkCapacity :=\n");
			if (sameNodeMapping) {
				// FIXME: Change the number 200 here!! (However it could be
				// any number.
				for (Iterator<SubstrateNode> nodes = substrate.getVertices()
						.iterator(); nodes.hasNext();) {
					SubstrateNode sNode = nodes.next();
					out.write(Long.toString(sNode.getId()) + " "
							+ Long.toString(sNode.getId()) + " \t\t"
							+ Double.toString(200) + "\n");
				}
			}
			for (Iterator<SubstrateLink> links = substrate.getEdges()
					.iterator(); links.hasNext();) {
				SubstrateLink temp = links.next();
				for (AbstractResource res : temp) {
					if (res instanceof BandwidthResource) {
						out.write(Long.toString(substrate.getSource(temp)
								.getId())
								+ " "
								+ Long.toString(substrate.getDest(temp)
										.getId())
								+ " \t\t"
								+ Double.toString(((BandwidthResource) res)
										.getAvailableBandwidth()) + "\n");
						break;
					}
				}
			}

			// write node capacities
			out.write(";\n\n");
			out.write("param: \t\tSNodeCapacity :=\n");
			for (Iterator<SubstrateNode> nodes = substrate.getVertices()
					.iterator(); nodes.hasNext();) {
				SubstrateNode temp = nodes.next();
				for (AbstractResource res : temp) {
					// Change it, and instance of abstract resource
					if (res instanceof CpuResource) {
						out.write(Long.toString(temp.getId())
								+ " \t\t"
								+ Double.toString(((CpuResource) res)
										.getAvailableCycles()) + "\n");
						break;
					}
				}
			}

			// Write virtual links bandwidth demands
			out.write(";\n\n");
			out.write("param: \t\tVLinkDemand :=\n");
			for (Iterator<VirtualLink> links = vNet.getEdges().iterator(); links
					.hasNext();) {
				VirtualLink temp = links.next();
				for (AbstractDemand dem : temp) {
					if (dem instanceof BandwidthDemand) {
						out.write(Long
								.toString(vNet.getSource(temp).getId())
								+ " "
								+ Long.toString(vNet.getDest(temp).getId())
								+ " \t\t"
								+ Double.toString(((BandwidthDemand) dem)
										.getDemandedBandwidth()) + "\n");
						break;
					}
				}
			}

			// write node demands
			out.write(";\n\n");
			out.write("param: \t\tVNodeDemand :=\n");
			for (Iterator<VirtualNode> nodes = vNet.getVertices().iterator(); nodes
					.hasNext();) {
				VirtualNode temp = nodes.next();
				for (AbstractDemand dem : temp) {
					// Change it, and instance of abstract resource
					if (dem instanceof CpuDemand) {
						out.write(Long.toString(temp.getId())
								+ " \t\t"
								+ Double.toString(((CpuDemand) dem)
										.getDemandedCycles()) + "\n");
						break;
					}
				}
			}

			// Write weight of each parameter
			out.write(";\n\n");
			out.write("param HHFactor := " + Double.toString(hhFactor) + ";\n");
			out.write("param RoundingFactor := "
					+ Double.toString(roundingFactor) + ";\n");

			out.write("param w1 := " + Double.toString(w1) + ";\n");
			out.write("param w2 := " + Double.toString(w2) + ";\n");
			out.write("param w3 := " + Double.toString(0.0001) + ";\n");

			out.write("param InactNodes := "
					+ Integer.toString(MiscelFunctions.getUnmappedNodes(
							substrate.getVertices()).size()) + ";\n");
			out.write("param InactLinks := "
					+ Integer.toString(MiscelFunctions.getUnmappedLinks(
							substrate.getEdges()).size()) + ";\n");
			
			out.write("param RemaRes := "
					+ Double.toString(MiscelFunctions.getRemaRes(
							substrate)) + ";\n");
			out.write("\n\nend;\n");
			// Close the output stream
			out.close();
		} catch (Exception e) {// Catch exception if any
			System.err.println("Error: " + e.getMessage());
		}
	}

	// PRIVATE //
	private FileWriter fstream;
}
